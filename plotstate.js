// Generated by CoffeeScript 1.12.5
var PlotState,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

PlotState = (function() {
  PlotState.prototype.topLeft = null;

  PlotState.prototype.pixelSize = null;

  PlotState.prototype.iter = 100;

  PlotState.prototype.slice = 1000;

  PlotState.prototype.reverseColor = false;

  PlotState.prototype.histColor = true;

  PlotState.prototype.smoothing = true;

  function PlotState(canvasId) {
    this.makePalette = bind(this.makePalette, this);
    this.colorFor = bind(this.colorFor, this);
    var canvas, ctx, renderState;
    renderState = void 0;
    canvas = $(canvasId).get(0);
    ctx = canvas.getContext("2d");
    this.reset = function() {
      this.topLeft = [-2.2, -1.1];
      return this.pixelSize = 2 * Math.abs(this.topLeft[1]) / canvas.height;
    };
    this.reset();
    this.startRender = function() {
      var BAILOUT, countHist, n, plotFn, points, ps, reColorFn, ref, rr, tx, ty, x, y;
      (renderState != null) && renderState.cancelTimerLoop();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ps = this.pixelSize;
      ref = this.topLeft, tx = ref[0], ty = ref[1];
      countHist = (function() {
        var i, ref1, results;
        results = [];
        for (n = i = 0, ref1 = this.iter; 0 <= ref1 ? i <= ref1 : i >= ref1; n = 0 <= ref1 ? ++i : --i) {
          results.push(0);
        }
        return results;
      }).call(this);
      points = (function() {
        var i, ref1, results;
        results = [];
        for (x = i = 0, ref1 = canvas.width - 1; 0 <= ref1 ? i <= ref1 : i >= ref1; x = 0 <= ref1 ? ++i : --i) {
          results.push((function() {
            var j, ref2, results1;
            results1 = [];
            for (y = j = 0, ref2 = canvas.height - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; y = 0 <= ref2 ? ++j : --j) {
              results1.push(0);
            }
            return results1;
          })());
        }
        return results;
      })();
      BAILOUT = 1 << 16;
      plotFn = (function(_this) {
        return function(point) {
          var count, fx, fy, ref1, xx, yy;
          x = point[0], y = point[1];
          fx = tx + x * ps;
          fy = ty + y * ps;
          ref1 = _this.pixelColor(fx, fy, _this.iter, BAILOUT), xx = ref1[0], yy = ref1[1], count = ref1[2];
          countHist[count]++;
          points[x][y] = [xx, yy, count];
          ctx.fillStyle = _this.colorFor(count / _this.iter);
          return ctx.fillRect(x, y, 1, 1);
        };
      })(this);
      reColorFn = (function(_this) {
        return function() {
          var clr1, clr2, colorStr, count, i, lerp, log2, nu, palette, ref1, results, xx, yy;
          if (!_this.histColor) {
            return;
          }
          palette = _this.makePalette(countHist, _this.iter);
          log2 = Math.log(2);
          lerp = function(a, b, frac) {
            return a + ((b - a) * frac);
          };
          results = [];
          for (x = i = 0, ref1 = canvas.width - 1; 0 <= ref1 ? i <= ref1 : i >= ref1; x = 0 <= ref1 ? ++i : --i) {
            results.push((function() {
              var j, ref2, ref3, results1;
              results1 = [];
              for (y = j = 0, ref2 = canvas.height - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; y = 0 <= ref2 ? ++j : --j) {
                ref3 = points[x][y], xx = ref3[0], yy = ref3[1], count = ref3[2];
                if (count >= this.iter) {
                  colorStr = this.colorFor(1);
                } else if (!this.smoothing) {
                  colorStr = this.colorFor(palette[count]);
                } else {
                  nu = Math.log((Math.log(xx + yy) / 2) / log2) / log2;
                  count += 1 - nu;
                  clr1 = palette[Math.floor(count)];
                  clr2 = palette[Math.floor(count) + 1];
                  colorStr = this.colorFor(lerp(clr1, clr2, count % 1));
                }
                ctx.fillStyle = colorStr;
                results1.push(ctx.fillRect(x, y, 1, 1));
              }
              return results1;
            }).call(_this));
          }
          return results;
        };
      })(this);
      rr = range(0, canvas.width - 1).permutedWith(range(0, canvas.height - 1));
      renderState = rr.forEach(plotFn, reColorFn);
      return renderState.timerLoop(this.slice);
    };
    this.isPlotting = function() {
      return (renderState != null) && renderState.notDone();
    };
    this.canvasExtent = function() {
      return [canvas.width, canvas.height];
    };
  }

  PlotState.prototype.pixelColor = function(ptX, ptY, maxIter, bailout) {
    var count, i, ref, ref1, x, xNew, xx, y, yy;
    ref = [0, 0, 0, 0], x = ref[0], y = ref[1], xx = ref[2], yy = ref[3];
    for (count = i = 0, ref1 = maxIter - 1; 0 <= ref1 ? i <= ref1 : i >= ref1; count = 0 <= ref1 ? ++i : --i) {
      if (xx + yy >= bailout) {
        return [xx, yy, count];
      }
      xNew = xx - yy + ptX;
      y = 2 * x * y + ptY;
      x = xNew;
      xx = x * x;
      yy = y * y;
    }
    return [0, 0, maxIter];
  };

  PlotState.prototype.colorFor = function(range) {
    var rgb;
    if (range >= 1) {
      return "#000000";
    }
    rgb = function(r, g, b) {
      var clr;
      clr = [r, g, b].map(function(c) {
        return Math.round(0x100 + c * 0xFF).toString(16);
      });
      return '#' + clr.map(function(c) {
        return ("0" + c).substr(-2);
      }).join("");
    };
    if (this.reverseColor) {
      range = 1 - range;
    }
    if (range <= 0.25) {
      return rgb(0, range / 0.25, 1);
    } else if (range <= 0.5) {
      return rgb(0, 1, 1 - (range - 0.25) / 0.25);
    } else if (range <= 0.75) {
      return rgb((range - 0.5) / 0.25, 1, 0);
    } else {
      return rgb(1, 1 - (range - 0.75) / 0.25, 0);
    }
  };

  PlotState.prototype.makePalette = function(hist, escape) {
    var hue, palette, sum;
    sum = hist.slice(0, +(escape - 1) + 1 || 9e9).reduce((function(_this) {
      return function(t, s) {
        return t + s;
      };
    })(this));
    hue = 0;
    palette = hist.map((function(_this) {
      return function(h) {
        hue += h;
        return hue / sum;
      };
    })(this));
    return palette;
  };

  PlotState.prototype.desc = function() {
    var stats;
    stats = [this.topLeft[0], this.topLeft[1]];
    stats = stats.map(function(x) {
      return Math.round(x * 1000000000) / 1000000000;
    });
    return "(" + stats[0] + ", " + stats[1] + "), pixel size = " + this.pixelSize;
  };

  PlotState.prototype.link = function() {
    return (this.topLeft[0] + "," + this.topLeft[1] + "," + this.pixelSize + "," + this.iter + ",") + ((this.reverseColor + 0) + "," + (this.histColor + 0) + "," + (this.smoothing + 0));
  };

  PlotState.prototype.setFromLink = function(afterHash) {
    var f, fields, i, iter, len, ps, reverse, smoothing, useHist, x, y;
    fields = afterHash.substring(1).split(',').map(function(s) {
      return parseFloat(s);
    });
    x = fields[0], y = fields[1], ps = fields[2], iter = fields[3], reverse = fields[4], useHist = fields[5], smoothing = fields[6];
    iter = Math.round(iter);
    if (!(fields.length >= 4)) {
      return;
    }
    for (i = 0, len = fields.length; i < len; i++) {
      f = fields[i];
      if (f === (0/0)) {
        return;
      }
    }
    if (!(ps > 0 && iter > 0)) {
      return;
    }
    this.topLeft = [x, y];
    this.pixelSize = ps;
    this.iter = iter;
    this.reverseColor = (reverse != null) && !!reverse;
    this.histColor = (useHist != null) && !!useHist;
    return this.smoothing = (smoothing != null) && !!smoothing;
  };

  PlotState.prototype.zoom = function(scale) {
    var ch, cw, newps, ref, scaleDiff;
    ref = this.canvasExtent(), cw = ref[0], ch = ref[1];
    newps = this.pixelSize * scale;
    scaleDiff = (newps - this.pixelSize) / 2;
    this.topLeft[0] -= cw * scaleDiff;
    this.topLeft[1] -= ch * scaleDiff;
    return this.pixelSize = newps;
  };

  PlotState.prototype.setRenderRect = function(x, y, width) {
    var ch, cw, ref;
    this.topLeft[0] += x * this.pixelSize;
    this.topLeft[1] += y * this.pixelSize;
    ref = this.canvasExtent(), cw = ref[0], ch = ref[1];
    this.pixelSize *= width;
    return this.pixelSize /= cw;
  };

  return PlotState;

})();
