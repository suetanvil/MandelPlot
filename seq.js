// Generated by CoffeeScript 1.12.5
var AbstractResumableCollection, ArrayCollection, PermutationCollection, Range, ResumableAction, range, wrap,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ResumableAction = (function() {
  ResumableAction.prototype.result = [];

  function ResumableAction(collection, completionHook, action) {
    var currentCompletionHook, finishEarly, index;
    index = 0;
    currentCompletionHook = completionHook;
    finishEarly = function() {
      return index = collection.size();
    };
    this.isDone = function() {
      return index >= collection.size();
    };
    this.restart = function() {
      var result;
      index = 0;
      result = [];
      return currentCompletionHook = completionHook;
    };
    this.resume = function(count) {
      var i, n, ref;
      if (count == null) {
        count = 1000;
      }
      if (this.isDone()) {
        return;
      }
      for (n = i = 1, ref = count; 1 <= ref ? i <= ref : i >= ref; n = 1 <= ref ? ++i : --i) {
        action(collection.at(index), this.result, finishEarly);
        ++index;
        if (this.isDone()) {
          if (currentCompletionHook != null) {
            currentCompletionHook(this);
            currentCompletionHook = void 0;
          }
          return;
        }
      }
    };
    this.finish = function() {
      return this.resume(collection.size());
    };
  }

  ResumableAction.prototype.timerLoop = function(count, delay) {
    var loopFn, quitNow;
    if (count == null) {
      count = 1000;
    }
    if (delay == null) {
      delay = 1;
    }
    this.cancelTimerLoop();
    quitNow = false;
    loopFn = (function(_this) {
      return function() {
        if (quitNow) {
          return;
        }
        _this.resume(count);
        if (_this.isDone()) {
          return;
        }
        return setTimeout(loopFn, delay);
      };
    })(this);
    setTimeout(loopFn, delay);
    return this.cancelTimerLoop = function() {
      return quitNow = true;
    };
  };

  ResumableAction.prototype.cancelTimerLoop = function() {
    return true;
  };

  ResumableAction.prototype.notDone = function() {
    return !this.isDone();
  };

  return ResumableAction;

})();

AbstractResumableCollection = (function() {
  function AbstractResumableCollection() {}

  AbstractResumableCollection.prototype.at = function(index) {
    throw "'at' not implemented.";
  };

  AbstractResumableCollection.prototype.size = function() {
    return -1;
  };

  AbstractResumableCollection.prototype.permutedWith = function(otherCollection) {
    return new PermutationCollection(this, otherCollection);
  };

  AbstractResumableCollection.prototype.forEach = function(callback, completionHook) {
    var wrapper;
    if (completionHook == null) {
      completionHook = void 0;
    }
    wrapper = function(item, result, exit) {
      return callback(item);
    };
    return new ResumableAction(this, completionHook, wrapper);
  };

  AbstractResumableCollection.prototype.map = function(callback, completionHook) {
    var wrapper;
    if (completionHook == null) {
      completionHook = void 0;
    }
    wrapper = function(item, result, exit) {
      return result.push(callback(item));
    };
    return new ResumableAction(this, completionHook, wrapper);
  };

  AbstractResumableCollection.prototype.filter = function(callback, completionHook) {
    var wrapper;
    if (completionHook == null) {
      completionHook = void 0;
    }
    wrapper = function(item, result, exit) {
      if (callback(item)) {
        return result.push(item);
      }
    };
    return new ResumableAction(this, completionHook, wrapper);
  };

  AbstractResumableCollection.prototype.every = function(callback, completionHook) {
    var exitWrapper, foundException, result, wrapper;
    if (completionHook == null) {
      completionHook = void 0;
    }
    foundException = false;
    result = true;
    wrapper = function(item, result, exit) {
      foundException = !callback(item);
      if (foundException) {
        result.push(false);
        return exit();
      }
    };
    exitWrapper = function(result) {
      if (!foundException) {
        result.push(true);
      }
      if (completionHook != null) {
        return completionHook(result);
      }
    };
    return new ResumableAction(this, exitWrapper, wrapper);
  };

  AbstractResumableCollection.prototype.some = function(callback, completionHook) {
    if (completionHook == null) {
      completionHook = void 0;
    }
    return this.every((function(elem) {
      return !callback(elem);
    }), completionHook);
  };

  return AbstractResumableCollection;

})();

Range = (function(superClass) {
  extend(Range, superClass);

  function Range(start, end, incr) {
    var length;
    if (incr == null) {
      incr = 1;
    }
    if (incr === 0) {
      throw "Zero increment value for Range";
    }
    length = ((end - start) / incr) + 1;
    length = Math.abs(Math.round(length));
    this.size = function() {
      return length;
    };
    this.at = function(index) {
      if (index >= length || index < 0) {
        return void 0;
      }
      return start + (index * incr);
    };
  }

  return Range;

})(AbstractResumableCollection);

range = function(start, end, incr) {
  if (incr == null) {
    incr = 1;
  }
  return new Range(start, end, incr);
};

PermutationCollection = (function(superClass) {
  extend(PermutationCollection, superClass);

  function PermutationCollection(first, second) {
    var length;
    length = first.size() * second.size();
    this.size = function() {
      return length;
    };
    this.at = function(index) {
      var li, ri;
      if (index >= length) {
        throw "Index " + index + " is out of bounds.";
      }
      li = index % first.size();
      ri = Math.floor(index / first.size());
      return [first.at(li), second.at(ri)];
    };
  }

  return PermutationCollection;

})(AbstractResumableCollection);

ArrayCollection = (function(superClass) {
  extend(ArrayCollection, superClass);

  function ArrayCollection(array) {
    this.size = function() {
      return array.length;
    };
    this.at = function(index) {
      return array[index];
    };
  }

  return ArrayCollection;

})(AbstractResumableCollection);

wrap = function(array) {
  return new ArrayCollection(array);
};
